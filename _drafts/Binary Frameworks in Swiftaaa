WWDC 2019에서 [**Binary Frameworks in Swift**](https://developer.apple.com/videos/play/wwdc2019/416/) 라는 세션으로 XCFramework를 발표했습니다.

xcodebuild archive -scheme XCFrameworkTest -archivePath "./build/ios.xcarchive" -sdk iphoneos SKIP_INSTALL=NO
xcodebuild archive -scheme XCFrameworkTest -archivePath "./build/ios_sim.xcarchive" -sdk iphonesimulator SKIP_INSTALL=NO
xcodebuild archive -scheme XCFrameworkTest -archivePath "./build/mac.xcarchive" SKIP_INSTALL=NO

xcodebuild archive -scheme XCFrameworkTest -archivePath "./build/ios.xcarchive" -sdk iphoneos SKIP_INSTALL=NO BUILD_LIBRARY_FOR_DISTRIBUTION=YES

xcodebuild -create-xcframework \
    -framework "./build/mac.xcarchive/Products/Library/Frameworks/XCFrameworkTest.framework" \
    -output "./build/XCFrameworkExample.xcframework"

///
xcodebuild -create-xcframework \
    -framework "./build/ios.xcarchive/Products/Library/Frameworks/XCFrameworkExample.framework" \
    -framework "./build/ios_sim.xcarchive/Products/Library/Frameworks/XCFrameworkExample.framework" \
    -framework "./build/macos.xcarchive/Products/Library/Frameworks/XCFrameworkExample.framework" \
    -output "./build/XCFrameworkExample.xcframework"



# WWDC 2019 - Binary Frameworks in Swift 정리

## Introducing XCFrameworks

XCFramework는 Xcode11부터 제공하는 새로운 포맷으로 여러 Framework 변형을 묶어 배포할 수 있습니다. Xcode가 지원하는 모든 플랫폼을 지원하며, AppKit을 사용하는 Mac App, UIKit을 사용하는 MacApp도 지원합니다.



Static 프레임워크와 해당 헤더도 묶을 수 있으며, Swift와 C 기반 코드의 바이너리 배포를 지원합니다.


Binary Frameworks in Swift

## XCFramework 설명

* Xcode 11에서 XCFramework라는 새로운 포맷을 사용하여 바이너리 라이브러리를 배포할 수 있습니다.
* XCFramework는 앞으로 Xcode 버전에서 여러가지 Framework를 묶는 새로운 방법입니다.
* 단일 XCFramework는 시뮬레이터와 디바이스 Framework를 가집니다.
* 단일 XCFramework는 Xcode가 지원하는 모든 플랫폼 형태를 포함합니다.
* AppKit을 사용하는 Map App과 UIKit을 사용하는 Mac App 형태도 가집니다.
* 고객이 어떤 API를 사용하든 간에 프레임워크를 효과적으로 사용할 수 있습니다.
* Framework를 묶을 수 있으며, 정적 라이브러리와 해당 헤더를 묶을 수 있습니다.
* XCFramework는 Swift와 C 기반 코드의 바이너리 배포를 지원합니다.
* Xcode 11에 `Build Libraries for Distribution` 라는 새로운 빌드 설정이 생겼습니다.
* Swift Framework를 보냈을 때 `Compiled module was created by a newer version of the compiler`라는 에러를 볼 수 있습니다. 이 에러는 Swift 컴파일러가 모듈을 가져오면서 Compiled Module이라는 파일(.swiftmodule)을 라이브러리에서 찾습니다. 이 파일을 찾으면 public API의 manifest를 읽고 모듈을 호출하고 사용할 수 있습니다. Compiled Module Format은 바이너리 포맷으로 내부 컴파일러 데이터 구조를 기본으로 포함합니다. 내부 데이터 구조일 뿐이므로 모든 Swift 컴파일러 버전에 따라 변경할 수 있습니다. 그래서 특정 Swift 버전을 사용한 모듈을 가져오려고 하고, 모듈은 다른 Swift 버전으로 만들었다면 컴파일러는 이해할 수 없습니다. 그러면 해당 모듈을 사용할 수 없습니다.
이 문제를 해결하기 위해 Xcode 11에는 Swift Module Interfaces라는 새로운 Swift Modules 형식이 도입되었습니다. 그리고 Compiled Module Format과 마찬가지로 모듈의 public API를 나열하지만 소스코드와 비슷한 텍스트 형식으로 나열합니다.

소스 코드처럼 동작하므로 이후 Swift 컴파일러 버전에도 이전 버전으로 작성된 모듈 인터페이스를 가져올 수 있습니다.

`Build Libraries for Distribution`를 활성화하면 컴파일러에게 프레임워크를 빌드 할 때마다 안정적인 인터페이스를 생성하도록 지시합니다.

첫번째로 메타 데이타 섹션을 살펴봅시다. 여기에 이 인터페이스를 생성한 컴파일러 버전이 포함되지만 Swift 컴파일러가 이 모듈로 가져오는데 필요한 Command line Flag의 하위집합도 포함되어 있습니다.

다음은 이 프레임워크가 가져오는 모든 모듈을 보고 인터페이스의 일부 타입을 봅시다. 
Spaceship class의 Public API입니다.
여기 세가지가 있습니다.

첫번째는 public name 속성은 인터페이스에 포함되어 있지만 private current location 속성은 포함되지 않습니다. 
public API의 일부가 아닙니다.
다음으로 public 생성자와 fly 메소드는 인터페이스에 포함되어 있음을 알 수 있습니다. 그러나 본문은 포함되지 않는데, public API의 일부가 아니기 때문입니다.
마지막으로 인터페이스에는 클래스가 초기화 해제(de-initializer)가 있지만 원래 소스 코드에는 작성되지 않았습니다.
스위프트에서 클래스를 작성할 때 명시적인 초기화 해제를 제공하지 않으면 컴파일러가 초기화 해제를 생성합니다.
그리고 이런 종류의 모듈 인터페이스의 기본 원리 중 하나를 강조합니다.
이 형식이 모든 컴파일러 버전에서 안정적으로 유지되어야 한다면, 컴파일러는 기본 소스 코드에 어떠 가정도 하지 않아야 합니다.
그래서 모듈 인터페이스에 포함시킵니다.
다음으로 Speed Enum을 을 살펴봅시다.
public API의 일부입니다. 
그러나 인터페이스에는 Hashable에 명시적 준수가 있습니다.
그리고 Hashable과 Equatable을 준수하기 위해 메소드를 나열합니다.
Swift에서는 Associted Value가 없는 Enum을 만들면, 컴파일러는 암시적으로 Equatable과 Hashable을 준수하도록하고 필요한 메소드를 자동으로 도출합니다. 
명시적이고 가정하지 않기 위해 Module Interface에 포함되어 있습니다.
마지막으로 Location Struct는 Public Stored 속성만 있고 적합성을 선언하지 않기 때문에 그대로 포함됩니다.
FlightKit의 모듈 인터페이스를 간략히 살펴 보겠습니다.
프레임 워크 내부의 내용을 살펴 보았으며, 배포 가능한 바이너리 XCFramework를 직접 빌드하는 방법을 설명하겠습니다.
프레임워크를 만드는 첫 단계는 Archive로 빌드 하는 것입니다.
프레임워크 아카이빙은 Release Mode로 빌드되고, 배포를 위해 패키징하며, Organizer Window에서 볼 수 있습니다.
아카이브에는 프레임워크의 해당 빌드에 해당하는 디버그 정보도 포함되어 있으며, 클라이언트가 프레임워크에서 발생하는 충돌이나 불안정성이 있으면 해당 정보를 사용를 보낼 수 있으며 심볼을 보고 디버깅을 할 수 있습니다.
프레임워크를 아카이브 하도록 xcodebuild arcive 명령을 사용할 수 있습니다.
프로젝트의 프레임워크의 스킴을 넘기고, 컴파일할 대상을 나열합니다.
iOS 용으로 빌드한다면, 이는 시뮬레이터용, 디바이스용, UIKit을 실행하는 Mac용일 수 있습니다.
Skip Install 빌드 설정을 No로 설정하여 넘겨야 합니다.
이는 xcodebuild archive가 archive 결과에 프레임워크를 설치하도록 지시합니다.
이 작업을 하면 Framework의 각각 변형 archive를 빌드하며 Preferences 윈도우에 Xcode Location tab의 Archive 폴더 내에 작성됩니다.
아카이브를 빌드하면 Framework를 추출할 수 있고, 하나의 XCFramework에 함께 묶을 수 있습니다.
이 작업은 xcodebuild -create-xcframework 명령을 실행합니다.
디스크에 있는 각 Framework 경로와 XCFramework를 출력할 경로를 전달합니다.
이것이 XCFramework를 만드는 방법입니다.
요약하자면, Build Libraries for Distribution을 활성화하려면 라이브러리를 배포되도록 빌드해야 합니다.
xcodebuild arcive를 실행하여 framework의 archive를 만들고, 마지막으로 xcodebuild -create-xcfraㅁmework를 실행하여 배포를 위한 패키지화 합니다.
클라이언트에게 보내기 시작하면 이것을 채택하기 시작합니다.
이것이 XCFramework입니다.

Framework Author Considerations

배포할때 마다 프레임워크 발전하는것
프레임워 발전시키는 것부터 시작.
프레임워크가 발전한다는 것은 무엇을 의마하는 것을까? 새로운 버전의 프레임워크가 출시될때마다 새로운 기능, 새로운 API, 일부 버그 수정이 있을 수 있으며, 소스 또는 바이너리 호환성이 깨지지 않고 되기를 원합니다.
바이너리 호환성은 왜 중요할까요? 클라이언트가 누구인지 알 필요가 없기 때문입니다.
많은 경우가 앱 타겟일겁니다.
프레임워크를 가져와 묶고 앱스토어에 보냅니다.
그러나 다른 경우에는 회사 또는 다른 회사의 바이너리 프레임워크 자체가 클라이언트가 있습니다.
이 경우 두 개의 별도의 릴리즈 스케쥴을 가집니다.
최신 버전으로 작업하는 동안 버전 2.1로 올라갈 수 있습니다.
그리고 마지막 버전 1.1로 배포할 때, 이를 채택하기 위한 추가 노력이 없습니다.
두 바이너리 프레임워크가 서로 버전이 고정되어 있는 상황을 원하지 않습니다. 어플리케이션은 업데이트를 하지 않기로 결정할 수 있기 때문입니다.
프레임워크 버전이 중요하며, 이를 웹 사이트나 문서에 게시하는게 아니라 프레임워크에 게시해야 하며, 프레임워크의 Info.plist의 Bundle version 문자열 설정에 해야합니다.

이 부분은 사람이 읽을 수 있는 버전 번호로 클라이언트에게 마지막 릴리즈 이후로 변경된 것을 알려줍니다.
그리고 Semantic Versioning 사용을 권장합니다.
Semantic Versioning을 간단히 리뷰하겠습니다.

가장 작은 구성 요소는 Patch Version이며, 버그 수정 또는 클라이언트에 영향이 미치지 않는 프레임워크의 구현 변경을 나타냅니다.

중간 구성 요소는 이전 버전과 호환되는 버전으로 새로운 API 또는 새로운 기능을 나타냅니다.
주요 구성 요소는 새로운 프레임워크 버전을 채택하기 위해 소스 변경, 바이너리 변경, Semantics 변경이든 클라이언트는 리빌드하고 클라이언트 코드의 일부를 다시 실행해야할 주요 변경사항 입니다.
FlightKit 모델 객체를 이용해서 실제로 어떻게 보이는지 봅시다.
하나씩 살펴보고 각 변경 사항이 프레임 워크의 버전 번호에 어떤 영향을 미치는지 살펴 보겠습니다

Spaceship 클래스에 새로운 private 속성을 추가했습니다.
Spaceship 생성자에서 사용합니다.
이 중 어느것도 Module Interface에 나타나지 않습니다.
프레임워크의 public API의 일부가 아닙니다.
따라서 이런 종류의 변경사항은 Minor나 Patch Version 요소만 업데이트하면 됩니다.
생성자의 동작을 변경했으므로, 이전 버전의 동작이 문서화 된 경우, 의미론적으로는 변경되므로, 클라이언트는 업데이트를 고려해야해야하므로 대신 주요 버전 번호를 변경해야 합니다.
다음 변경 사항으로 Spaceship 클래스에 새로운 메소드를 추가했습니다.
새로운 public 메소드로, 클라이언트가 사용할 수 있습니다.
따라서 올바른 방법은 Minor Version 번호를 증가시키는 것입니다.
Patch Version도 0으로 초기화합니다.
마지막으로 fly 메소드에 새 매개변수를 추가했습니다.
대부분 사용하는 경우 변경할 필요없도록 기본 값을 지정했습니다.
그러나 Swift에서는 함수는 이름과 매개변수가 고유하게 식별됩니다.
인수 레이블과 타입 모두다.
소스와 바이너리 호환성을 모두 깨트렸으므로 주요 버전 번호를 업데이트 하고, 클라이언트에게 다시 컴파일하도록 요청해야합니다.
어쩌면 대신 새로운 과부하를 만들어야 했습니까? 이것들은 Spaceship 클래스의 모든 변경사항이지만 FlightKit의 일부 값 타입도 변경했습니다.
Speed Enum에 새로운 Case를 추가했습니다.
Location에 Hashable을 추가하고, 클라이언트는 이 세트를 가질 수 있습니다. 소스나 바이너리 호환성을 손상시키지 않고 Location 구조체에 새로운 stored 속성을 추가했습니다.
이제 Swift에 이러한 모든 변경 사항이 이전 버전과 호환되므로 Minor Version 번호만 올리면 됩니다.
이제 이 유연성은 프레임워크의 API를 설계하는 방법에 일부 영향을 미칩니다.
가장 중요한 것은 작게 시작하는 것입니다.
필요한 기능이 있거나 클라이언트가 더 많은 기능이 필요하다는 피드백을 제출하면 새로운 기능을 쉽게 추가 할 수 있습니다.
그러나 적어도 하나의 클라이언트에 소스 또는 바이너리 호환성을 손상시킬 가능성이 있기 때문에 무언가를 제거하기가 실제로 어렵습니다.
유형 이름과 같이 사실 이후에 변경할 수없는 사항에 대해서는 이름을 신중하게 고려하십시오. 해당 이름은 이 릴리스에서만 의미가있을뿐 아니라 모든 것에서도 의미가 있습니다. 향후 릴리스.
마지막으로 확장 성을 너무 일찍 추가하지 마십시오.
클래스


Trading Flexibility for Optimizability

우리는 프레임워크 작성자로서 소스 또는 바이너리 호환성을 손상시키지 않고 변경하고, 추가하고, 개선 할 수 있는 유연성을 원합니다.
그러나 컴파일러가 클라이언트 코드를 가능한 빨리 만들려면 프레임 워크에 무엇이 있는지 가정해야합니다.
따라서 Swift는 스펙트럼의 양쪽을 모두 처리 할 수 있어야합니다.
이것이 작동하는 방식은 Build Libraries for Distribution 빌드 설정을 통하는 것입니다.
Harlan은 Module Interface 파일을 생성하는 것 외에도 여러 가지 효과가 있으며 그중 하나는 기본값을 유연성 측면으로 설정하는 것입니다.
Swift는 모든 사용 사례를 다룰 수 있어야 하므로, 이 섹션에서는 프레임워크의 동작을 외부에서 프로파일링 한 후 추가 성능이 필요합니다.
이를 수행하는 세 가지 방법: inlinable functions, frozen enums 및 frozen structs.
작년에 Swift 4.2에 도입 된 기능인 inlinable 함수부터 시작하겠습니다.
Spaceship 클래스의 CargoShip 서브클래스가 있고, CargoShip이 일부 cargo를 운반할 수 있는지 여부를 결정하는 canCarry 메소드가 있습니다.
클라이언트의 성능이 중요하다고 생각하여 inlinable을 추가했습니다.
inlinable은 메소드 뿐만 아니라 본문을 public 인터페이스의 일부로 만듭니다.
Module Interface 파일에 본문을 복사합니다.
매우 빠르게 읽는다면 메소드가 CargoShip 클래스의 내부 속성을 참조하는 것도 알 수 있습니다.
usableFromInline으로 속성을 마크했기 때문에 가능합니다.
이 속성이 프레임워크의 public 인터페이스의 일부로 가능하지만 inlinable 코드에서만 사용이 가능합니다.
외부 클라이언트가 임의로 읽거나 쓰는 것이 방지됩니다.
그래서 internal이지만 usableFromInline 입니다.

선언할때마다 결정된다는 점에 유의해야 합니다.
currentCargo 속성은 internal이고, Module Interface에는 포함되지 않습니다.
Module Interface에 canCarry 메소드의 본문이 있습니다.
클라이언트가 해당 인터페이스에 대해 컴파일을 할 때, 해당 본문을 직접 코드에 복사하며, 체크중인 cargo에 대해 알고 있는 경우 더 최적화 할 수 있습니다.
프레임워크 소유자가 메소드의 본문을 변경하고 클라이언트가 재컴파일을 하지 않으면 어떻게 될까요? 예를 들어, CargoShip이 Radioactive cargo는 운반할 수 없다는 새로운 규칙이 있다면 어떻게 될까요? 이 경우에는 문제가 생길 것입니다.
이제 프로그램의 다른 두 부분에서 이 메소드가 무엇을 해야하는지 생각이 달라지기 때문입니다.

일반 Cargo인 경우는 클라이언트와 프레임워크는 괜찮다고 말합니다.
그러나 Radioactive cargo를 테스트하려고 하면, 클라이언트 코드는 컴파일될 때 Module Interface에서 보았기때문에 괜찮다고 말할 것입니다.
프레임워크는 새로운 버전의 메소드가 있지만 허용하지 않을 것입니다.
프로그램에 심각한 논리 오류를 나타낼 수 있습니다.
경험적으로 @inlinable 함수를 만든 프레임워크 작성자는 출력이나 관찰 가능한 동작을 변경하지 않아야 합니다.
더 나은 알고리즘이나 fast pad를 추가하는 것은 괜찮지만, 함수의 관찰 가능한 동작을 변경하면 런타임시, 특정 입력에서만 볼 수 있는 미묘한 문제가 발생할 수 있습니다.
이 작업을 해야한다면, 모든 클라이언트가 컴파일을 다시 해야합니다.

다음으로 열거 형에 대해 이야기하고 싶습니다.
스위프트 열거 형은 훌륭합니다.
여기에서 한가지 이야기 할 것은 소스나 바이너리 호환성을 깨트리지 않고도 새로운 case를 enum에 추가할 수 있습니다.
이는 클라이언트가 default case가 항상 있어야 한다는 것입니다.
클라이언트에서는 Swift 4.2에서 도입한 @unknown default 구문을 사용하기로 결정했습니다.

이는 enum에서 알려진 모든 case를 다뤘지만, 미래에 추가되는 case를 처리한다는 의미입니다. 

///다른 효과로 앞에서 이야기한 것에서 클라이언트와 프레임워크 간의 handshake 종류로 enum의 크기와 정리가 필요한 지에 대한 것입니다.

frozen 속성을 enum에 표시하면, 프레임워크 작성자는 향후 릴리즈에 새로운 case가 추가되지 않는는 약속을 할 수 있습니다.
첫번째 효과로 클라이언트는 더이상 default case를 작성할 필요가 없습니다.
컴파일러는 더 효율적으로 컴파일을 할 수 있습니다.
클라이언트는 enum에 추가 case가 없어 정리할 필요가 없다고 가정할 수 있습니다.
Flight Plan에 새로운 case를 추가했습니다.
클라이언트 코드는 default case가 없으므로, @frozen enum에 새로운 case를 소스와 바이너리에 추가하고, Major 버전을 증가하고 모든 클라이언트에 컴파일을 다시 해야합니다.
@frozen Struct도 거의 같습니다.
기본적으로 바이너리 프레임워크의 struct는 새로운 stored 속성을 추가되거나 기존 속성일 재정렬하는데 문제 없지만, 클라이언트와 프레임워크 간의 handshake의 같은 종류와 추가 커뮤니케이션이 발생합니다.

이것을 방지하기 위해 frozen layout을 가지는 것으로 알려진 struct는 @frozen 속성을 사용하여 stored 속성이 변경되지 않음을 약속할 수 있습니다.
추가되거나 순서 변경 또는 제거되지 않습니다.
그리고 다른 하나는 stored 속성의 타입은 모두 public이거나 @usableFromInline이어야 합니다.
컴파일러가 클라이언트 코드로 작업할 때, 직접 구조체의 stored 속성을 조작하여 클라이언트 사이드에 매우 효율적인 코드를 생성하기를 원합니다.
이는 매우 의미론적인 효과를 가지는데, 프레임워크 작성자는 @inlinable 생성자를 작성할 수 있습니다.
생성자는 모든 stored 속성을 설정하는 것을 요구하는데, 컴파일러는 이후 버전의 프레임워크에서도 그렇게 할 것이라고 확신할 수 있습니다.
Flexibility가 기본이라는 것을 상기시켜 이 섹션을 마무리 합니다.
변경사항은 클라이언트에게 정말로 불편하다는 점입니다.
클라이언트는 프레임워크 새 버전을 사용할지 여부를 다시 추측합니다 이는 어떤 방식으로든 깨질 수 있기 때문입니다.
또한 다른 바이너리 프레임워크에 바이너리 프레임워크가 문제가 발생할 수 있습니다.
이러한 속성은 클라이언트 코드에만 영향을 미칩니다.
프레임워크 내에선 여전히 컴파일러 최적화의 모든 기능을 이용할 수 있습니다.
@frozen 또는 @inlinable에 접근하기 전에 외부에서 프레임워크의 동작을 프로파일링하고 추가 성능이 필요하다는 것을 입증해야 합니다.
그렇지 않으면 필요할 수 있으므로 Flexibility를 유지하세요.

이제 마지막 섹션으로 고객의 경험이 최상인지를 확인하는 것입니다.

Entitlements로 시작합니다.
프레임워크는 작업이 끝났을 때 특정 Entitlements를 필요로 합니다. 기본부터 시작해봅시다.
잠재적인 클라이언트가 프레임워크를 성공적으로 채택하기 위해 할일을 알 수 있도록 문서화를 해야합니다.
또한, 특정 프레임워크의 권한 요청하는 것을 최소화하며, 이는 더 많은 컨텍스트에 적용할 수 있음을 의미합니다.
프레임워크를 사용하여 더 많은 고객을 확보할 수 있습니다.
프레임워크와 어플리케이션은 유저에게 권한을 요청할 수 있지만, 궁극적으로 권한 부여 여부는 고객의 선택임을 명심하십시오.
특정 권한이 거부되면 프레임워크가 해당 거부를 정상적으로 처리하는지 확인해야 합니다.
앱은 크래시나거나 작동이 멈추지 않아야 합니다.
클라이언트는 포기하지 않고 프레임워크를 사용할 수 있도록 여전히 유용한 작업을 하도록 해야합니다.
의존성은 Entitlements과 동일한 관심를 가지고 있습니다.
Entitlements과 비슷하게, 프레임워크의 의존성은 어플리케이션의 의존성이 됩니다.
그리고 다시 잠재 클라이언트가 무엇을 신청하는지 알 수 있도록 문서화를 시작해야 합니다.
의존성을 최소화하여 클라이언트를 덜 요구하도록 합니다.
신뢰 확장(extending trust)과 의존성이 차지하는 코드 사이즈와 같은 실제적인 문제도 적습니다.
마지막으로 Build Libraries for Distribution 빌드 설정을 사용하여 모든 의존성을 빌드하여 바이너리 호환성 보장을 해야합니다.
바이너리 프레임워크가 패키지에 의존할 수 없다는 특별한 의미가 있습니다.

의존성 그래프를 봅시다.
몇분 전에 프레임워크의 의존성이 앱에 종속된다고 말했습니다.
앱이 패키지를 빌드할 때 특정 태그를 선택해야 합니다.
프레임워크가 가지는 버전과 일치하지 않을 수 있습니다.
호환되지 않을 수 있습니다.
그 외에도 모든 프레임워크가 Build Libraries for Distribution로 호환되게 빌드될 수 있는 것은 아닙니다.
이 설정은 지원되지 않습니다.
마지막으로 말씀 드리고 싶은 것은 Objective-C Interface입니다.
Swift 프레임워크 작성자는 Objective-C Interface가 대부분 있으며, 이는 Xcode 기본 템플릿이 Objective-C Umbrella Header와 Swift의 Objective-C 일부를 포함하는 생성된 Header가 설정되어 있습니다.
Swift 코드에 Objective-C API가 없으면 Second Header를 전혀 설치할 필요가 없습니다.
Swift Compiler - Genenal의 Install Objective-C Compatibility Header 빌드 설정을 끌 수 있습니다.
프레임워크가 Objective-C API를 제공하지 않으면 Objective-C Import 구문을 지원할 이유가 없으며, Packing의 Defines Module Build 빌드 설정을 끌 수 있습니다.
No로 설정하면 더 이상 유효한 Objective-C 코드가 아닙니다.
Xcode가 생성한 Umbrella Header를 삭제할 수 있습니다.

오늘 많은 것을 이야기 했지만 가장 중요한 것은 XCFrameworks입니다
사용자가 매우 쉽게 여러 프레임워크 변형을 배포하기 위한 새로운 Bundle 형식입니다.
XCFrameworks를 빌드하려면 적절한 바이너리 호환 프레임워크를 얻는데 필요한 항목인 Build Libraries for Distribution 빌드 설정을 켜야합니다.
프레임워크 소유자는 고객에게 제공해야 할 책임을 잘 알고 있어야 최상의 서비스를 제공할 수 있습니다.
