Binary Frameworks in Swift

## XCFramework 설명

* Xcode 11에서 XCFramework라는 새로운 포맷을 사용하여 바이너리 라이브러리를 배포할 수 있습니다.
* XCFramework는 앞으로 Xcode 버전에서 여러가지 Framework를 묶는 새로운 방법입니다.
* 단일 XCFramework는 시뮬레이터와 디바이스 Framework를 가집니다.
* 단일 XCFramework는 Xcode가 지원하는 모든 플랫폼 형태를 포함합니다.
* AppKit을 사용하는 Map App과 UIKit을 사용하는 Mac App 형태도 가집니다.
* 고객이 어떤 API를 사용하든 간에 프레임워크를 효과적으로 사용할 수 있습니다.
* Framework를 묶을 수 있으며, 정적 라이브러리와 해당 헤더를 묶을 수 있습니다.
* XCFramework는 Swift와 C 기반 코드의 바이너리 배포를 지원합니다.
* Xcode 11에 `Build Libraries for Distribution` 라는 새로운 빌드 설정이 생겼습니다.
* Swift Framework를 보냈을 때 `Compiled module was created by a newer version of the compiler`라는 에러를 볼 수 있습니다. 이 에러는 Swift 컴파일러가 모듈을 가져오면서 Compiled Module이라는 파일(.swiftmodule)을 라이브러리에서 찾습니다. 이 파일을 찾으면 public API의 manifest를 읽고 모듈을 호출하고 사용할 수 있습니다. Compiled Module Format은 바이너리 포맷으로 내부 컴파일러 데이터 구조를 기본으로 포함합니다. 내부 데이터 구조일 뿐이므로 모든 Swift 컴파일러 버전에 따라 변경할 수 있습니다. 그래서 특정 Swift 버전을 사용한 모듈을 가져오려고 하고, 모듈은 다른 Swift 버전으로 만들었다면 컴파일러는 이해할 수 없습니다. 그러면 해당 모듈을 사용할 수 없습니다.
이 문제를 해결하기 위해 Xcode 11에는 Swift Module Interfaces라는 새로운 Swift Modules 형식이 도입되었습니다. 그리고 Compiled Module Format과 마찬가지로 모듈의 public API를 나열하지만 소스코드와 비슷한 텍스트 형식으로 나열합니다.

소스 코드처럼 동작하므로 이후 Swift 컴파일러 버전에도 이전 버전으로 작성된 모듈 인터페이스를 가져올 수 있습니다.

`Build Libraries for Distribution`를 활성화하면 컴파일러에게 프레임워크를 빌드 할 때마다 안정적인 인터페이스를 생성하도록 지시합니다.

첫번째로 메타 데이타 섹션을 살펴봅시다. 여기에 이 인터페이스를 생성한 컴파일러 버전이 포함되지만 Swift 컴파일러가 이 모듈로 가져오는데 필요한 Command line Flag의 하위집합도 포함되어 있습니다.

다음은 이 프레임워크가 가져오는 모든 모듈을 보고 인터페이스의 일부 타입을 봅시다. 
Spaceship class의 Public API입니다.
여기 세가지가 있습니다.

첫번째는 public name 속성은 인터페이스에 포함되어 있지만 private current location 속성은 포함되지 않습니다. 
public API의 일부가 아닙니다.
다음으로 public 생성자와 fly 메소드는 인터페이스에 포함되어 있음을 알 수 있습니다. 그러나 본문은 포함되지 않는데, public API의 일부가 아니기 때문입니다.
마지막으로 인터페이스에는 클래스가 초기화 해제(de-initializer)가 있지만 원래 소스 코드에는 작성되지 않았습니다.
스위프트에서 클래스를 작성할 때 명시적인 초기화 해제를 제공하지 않으면 컴파일러가 초기화 해제를 생성합니다.
그리고 이런 종류의 모듈 인터페이스의 기본 원리 중 하나를 강조합니다.
이 형식이 모든 컴파일러 버전에서 안정적으로 유지되어야 한다면, 컴파일러는 기본 소스 코드에 어떠 가정도 하지 않아야 합니다.
그래서 모듈 인터페이스에 포함시킵니다.
다음으로 Speed Enum을 을 살펴봅시다.
public API의 일부입니다. 
그러나 인터페이스에는 Hashable에 명시적 준수가 있습니다.
그리고 Hashable과 Equatable을 준수하기 위해 메소드를 나열합니다.
Swift에서는 Associted Value가 없는 Enum을 만들면, 컴파일러는 암시적으로 Equatable과 Hashable을 준수하도록하고 필요한 메소드를 자동으로 도출합니다. 
명시적이고 가정하지 않기 위해 Module Interface에 포함되어 있습니다.
마지막으로 Location Struct는 Public Stored 속성만 있고 적합성을 선언하지 않기 때문에 그대로 포함됩니다.
FlightKit의 모듈 인터페이스를 간략히 살펴 보겠습니다.
프레임 워크 내부의 내용을 살펴 보았으며, 배포 가능한 바이너리 XCFramework를 직접 빌드하는 방법을 설명하겠습니다.
프레임워크를 만드는 첫 단계는 Archive로 빌드 하는 것입니다.
프레임워크 아카이빙은 Release Mode로 빌드되고, 배포를 위해 패키징하며, Organizer Window에서 볼 수 있습니다.
아카이브에는 프레임워크의 해당 빌드에 해당하는 디버그 정보도 포함되어 있으며, 클라이언트가 프레임워크에서 발생하는 충돌이나 불안정성이 있으면 해당 정보를 사용를 보낼 수 있으며 심볼을 보고 디버깅을 할 수 있습니다.
프레임워크를 아카이브 하도록 xcodebuild arcive 명령을 사용할 수 있습니다.
프로젝트의 프레임워크의 스킴을 넘기고, 컴파일할 대상을 나열합니다.
iOS 용으로 빌드한다면, 이는 시뮬레이터용, 디바이스용, UIKit을 실행하는 Mac용일 수 있습니다.
Skip Install 빌드 설정을 No로 설정하여 넘겨야 합니다.
이는 xcodebuild archive가 archive 결과에 프레임워크를 설치하도록 지시합니다.
이 작업을 하면 Framework의 각각 변형 archive를 빌드하며 Preferences 윈도우에 Xcode Location tab의 Archive 폴더 내에 작성됩니다.
아카이브를 빌드하면 Framework를 추출할 수 있고, 하나의 XCFramework에 함께 묶을 수 있습니다.
이 작업은 xcodebuild -create-xcframework 명령을 실행합니다.
디스크에 있는 각 Framework 경로와 XCFramework를 출력할 경로를 전달합니다.
이것이 XCFramework를 만드는 방법입니다.
요약하자면, Build Libraries for Distribution을 활성화하려면 라이브러리를 배포되도록 빌드해야 합니다.
xcodebuild arcive를 실행하여 framework의 archive를 만들고, 마지막으로 xcodebuild -create-xcfraㅁmework를 실행하여 배포를 위한 패키지화 합니다.
클라이언트에게 보내기 시작하면 이것을 채택하기 시작합니다.
이것이 XCFramework입니다.

Framework Author Considerations

배포할때 마다 프레임워크 발전하는것
프레임워 발전시키는 것부터 시작.
프레임워크가 발전한다는 것은 무엇을 의마하는 것을까? 새로운 버전의 프레임워크가 출시될때마다 새로운 기능, 새로운 API, 일부 버그 수정이 있을 수 있으며, 소스 또는 바이너리 호환성이 깨지지 않고 되기를 원합니다.
바이너리 호환성은 왜 중요할까요? 클라이언트가 누구인지 알 필요가 없기 때문입니다.
많은 경우가 앱 타겟일겁니다.
프레임워크를 가져와 묶고 앱스토어에 보냅니다.
그러나 다른 경우에는 회사 또는 다른 회사의 바이너리 프레임워크 자체가 클라이언트가 있습니다.
이 경우 두 개의 별도의 릴리즈 스케쥴을 가집니다.
최신 버전으로 작업하는 동안 버전 2.1로 올라갈 수 있습니다.
그리고 마지막 버전 1.1로 배포할 때, 이를 채택하기 위한 추가 노력이 없습니다.
두 바이너리 프레임워크가 서로 버전이 고정되어 있는 상황을 원하지 않습니다. 어플리케이션은 업데이트를 하지 않기로 결정할 수 있기 때문입니다.
프레임워크 버전이 중요하며, 이를 웹 사이트나 문서에 게시하는게 아니라 프레임워크에 게시해야 하며, 프레임워크의 Info.plist의 Bundle version 문자열 설정에 해야합니다.

이 부분은 사람이 읽을 수 있는 버전 번호로 클라이언트에게 마지막 릴리즈 이후로 변경된 것을 알려줍니다.
그리고 Semantic Versioning 사용을 권장합니다.
Semantic Versioning을 간단히 리뷰하겠습니다.

가장 작은 구성 요소는 Patch Version이며, 버그 수정 또는 클라이언트에 영향이 미치지 않는 프레임워크의 구현 변경을 나타냅니다.

중간 구성 요소는 이전 버전과 호환되는 버전으로 새로운 API 또는 새로운 기능을 나타냅니다.
주요 구성 요소는 새로운 프레임워크 버전을 채택하기 위해 소스 변경, 바이너리 변경, Semantics 변경이든 클라이언트는 리빌드하고 클라이언트 코드의 일부를 다시 실행해야할 주요 변경사항 입니다.
FlightKit 모델 객체를 이용해서 실제로 어떻게 보이는지 봅시다.
하나씩 살펴보고 각 변경 사항이 프레임 워크의 버전 번호에 어떤 영향을 미치는지 살펴 보겠습니다

Spaceship 클래스에 새로운 private 속성을 추가했습니다.
Spaceship 생성자에서 사용합니다.
이 중 어느것도 Module Interface에 나타나지 않습니다.
프레임워크의 public API의 일부가 아닙니다.
따라서 이런 종류의 변경사항은 Minor나 Patch Version 요소만 업데이트하면 됩니다.
생성자의 동작을 변경했으므로, 이전 버전의 동작이 문서화 된 경우, 의미론적으로는 변경되므로, 클라이언트는 업데이트를 고려해야해야하므로 대신 주요 버전 번호를 변경해야 합니다.
다음 변경 사항으로 Spaceship 클래스에 새로운 메소드를 추가했습니다.
새로운 public 메소드로, 클라이언트가 사용할 수 있습니다.
따라서 올바른 방법은 Minor Version 번호를 증가시키는 것입니다.
Patch Version도 0으로 초기화합니다.
마지막으로 fly 메소드에 새 매개변수를 추가했습니다.
대부분 사용하는 경우 변경할 필요없도록 기본 값을 지정했습니다.
그러나 Swift에서는 함수는 이름과 매개변수가 고유하게 식별됩니다.
인수 레이블과 타입 모두다.
소스와 바이너리 호환성을 모두 깨트렸으므로 주요 버전 번호를 업데이트 하고, 클라이언트에게 다시 컴파일하도록 요청해야합니다.
어쩌면 대신 새로운 과부하를 만들어야 했습니까? 이것들은 Spaceship 클래스의 모든 변경사항이지만 FlightKit의 일부 값 타입도 변경했습니다.
Speed Enum에 새로운 Case를 추가했습니다.
Location에 Hashable을 추가하고, 클라이언트는 이 세트를 가질 수 있습니다. 소스나 바이너리 호환성을 손상시키지 않고 Location 구조체에 새로운 stored 속성을 추가했습니다.
이제 Swift에 이러한 모든 변경 사항이 이전 버전과 호환되므로 Minor Version 번호만 올리면 됩니다.
이제 이 유연성은 프레임워크의 API를 설계하는 방법에 일부 영향을 미칩니다.
가장 중요한 것은 작게 시작하는 것입니다.
필요한 기능이 있거나 클라이언트가 더 많은 기능이 필요하다는 피드백을 제출하면 새로운 기능을 쉽게 추가 할 수 있습니다.
그러나 적어도 하나의 클라이언트에 소스 또는 바이너리 호환성을 손상시킬 가능성이 있기 때문에 무언가를 제거하기가 실제로 어렵습니다.
유형 이름과 같이 사실 이후에 변경할 수없는 사항에 대해서는 이름을 신중하게 고려하십시오. 해당 이름은 이 릴리스에서만 의미가있을뿐 아니라 모든 것에서도 의미가 있습니다. 향후 릴리스.
마지막으로 확장 성을 너무 일찍 추가하지 마십시오.
클래스


Trading Flexibility for Optimizability

우리는 프레임워크 작성자로서 소스 또는 바이너리 호환성을 손상시키지 않고 변경하고, 추가하고, 개선 할 수 있는 유연성을 원합니다.
그러나 컴파일러가 클라이언트 코드를 가능한 빨리 만들려면 프레임 워크에 무엇이 있는지 가정해야합니다.
따라서 Swift는 스펙트럼의 양쪽을 모두 처리 할 수 있어야합니다.
이것이 작동하는 방식은 Build Libraries for Distribution 빌드 설정을 통하는 것입니다.
Harlan은 Module Interface 파일을 생성하는 것 외에도 여러 가지 효과가 있으며 그중 하나는 기본값을 유연성 측면으로 설정하는 것입니다.
Swift는 모든 사용 사례를 다룰 수 있어야 하므로, 이 섹션에서는 프레임워크의 동작을 외부에서 프로파일링 한 후 추가 성능이 필요합니다.
이를 수행하는 세 가지 방법: inlinable functions, frozen enums 및 frozen structs.
작년에 Swift 4.2에 도입 된 기능인 inlinable 함수부터 시작하겠습니다.
Spaceship 클래스의 CargoShip 서브클래스가 있고, CargoShip이 일부 cargo를 운반할 수 있는지 여부를 결정하는 canCarry 메소드가 있습니다.
클라이언트의 성능이 중요하다고 생각하여 inlinable을 추가했습니다.
inlinable은 메소드 뿐만 아니라 본문을 public 인터페이스의 일부로 만듭니다.
Module Interface 파일에 본문을 복사합니다.
매우 빠르게 읽는다면 메소드가 CargoShip 클래스의 내부 속성을 참조하는 것도 알 수 있습니다.
usableFromInline으로 속성을 마크했기 때문에 가능합니다.
이 속성이 프레임워크의 public 인터페이스의 일부로 가능하지만 inlinable 코드에서만 사용이 가능합니다.
외부 클라이언트가 임의로 읽거나 쓰는 것이 방지됩니다.
그래서 internal이지만 usableFromInline 입니다.


이 경우, 앞에서 본 우주선 클래스의 CargoShip 서브 클래스가 있으며, CarCarShip이 일부화물을 운반 할 수 있는지 여부를 결정하는 canCarry 메소드가 있습니다.
  나는 이것이 고객의 성과에 중요하다고 생각하기 때문에 이것을 무가치하게 만들었습니다.
  이것이 할 일은이 메소드를 선언뿐만 아니라 본문의 공용 인터페이스의 일부로 만드는 것입니다.
  그 효과는 해당 본문을 모듈 인터페이스 파일에 복사하는 것입니다.
  매우 빠르게 읽는다면이 메소드가 CargoShip 클래스의 내부 속성을 참조한다는 것도 알 수 있습니다.
  그 속성은 인라인에서 사용 가능한 것으로 표시했기 때문에 가능합니다.
  이를 통해 두 세계를 모두 활용할 수 있습니다.
  이 속성은 프레임 워크의 퍼블릭 인터페이스의 일부로 제공되지만, inlinable 코드에서만 사용할 수 있습니다.
  외부 클라이언트가 임의로 읽거나 쓰는 것을 방지합니다.